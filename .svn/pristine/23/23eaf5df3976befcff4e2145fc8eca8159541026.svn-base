DBConnectorIndexedDB.prototype = new DBConnector();

DBConnectorIndexedDB.prototype.getIndexedDB = function(){
	return indexedDB || window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB;
}

// Patch IndexedDB's standard function to add automatic changes detection.
DBConnectorIndexedDB.prototype.monkeyPatch = function(){
	console.log("Patching IndexedDB functions...");
	var indexedDB = this.getIndexedDB();
	var self = this;
	// Patch "add" function of IndexedDB, to automatically mark object as inserted and in needing sync.
	IDBObjectStore.prototype.addSTD = IDBObjectStore.prototype.add;
	IDBObjectStore.prototype.add = function(data,key){
		var markupKey = key ? key : (this.keyPath ? data[this.keyPath] : null);
		if ( markupKey )
			self.markAsUpserted(this.name, [markupKey]);
		console.log("IDBObjectStore.add " + JSON.stringify(data) + " key=" + JSON.stringify(markupKey));
		return this.addSTD(data,key);
	};
	// Patch "put" function of IndexedDB, to automatically mark object as modified and in needing sync.
	IDBObjectStore.prototype.putSTD = IDBObjectStore.prototype.put;
   	IDBObjectStore.prototype.put = function(data,key){
		var markupKey = key ? key : (this.keyPath ? data[this.keyPath] : null);
		if ( markupKey )
			self.markAsUpserted(this.name, [markupKey]);		// put may add or modify object.
		console.log("IDBObjectStore.put " + JSON.stringify(data) + " key=" + JSON.stringify(markupKey));
		return this.putSTD(data,key);
	};
	// Patch "delete" function of IndexedDB, to automatically mark object as deleted and in needing sync.
	IDBObjectStore.prototype.deleteSTD = IDBObjectStore.prototype.delete;
	IDBObjectStore.prototype.delete = function(key){
		console.log("IDBObjectStore.delete key=" + JSON.stringify(key));
		if ( key )
			self.markAsDeleted(this.name, [key]);
		return this.deleteSTD(key);
	};
	console.log("...patched");
};


//DBConnectorIndexedDB.prototype.initDB = function(tablesToSync) {
/* DBConnectorIndexedDB.prototype.initDB = function() {
	var open = this.getIndexedDB().open(this.dbName, this.dbVersion);
	// open.onupgradeneeded = function() {
		// // Apply schema if any...TODO
	// };
	var self = this;
	open.onsuccess = function(){
		self.db = open.result;
	};
}; */

DBConnectorIndexedDB.prototype.initDB = function() {
	var self = this;
	return new Promise(function(resolve,reject){
		var open = self.getIndexedDB().open(self.dbName, self.dbVersion);
		// open.onupgradeneeded = function() {
			// // Apply schema if any...TODO
		// };
		open.onsuccess = function(){
			self.db = open.result;
			resolve(self.db);
		};
	});
};

DBConnectorIndexedDB.prototype.get = function(tableName, key) {
	var self = this;
	return new Promise(function(resolve, reject){
		var tx = self.db.transaction(tableName, "readwrite");
		var store = tx.objectStore(tableName);
		var request = store.get(key);
		request.onsuccess = function(){
			var element = {};
			element.key = key;
			element.value = request.result;
			resolve(element);
		}
	});
};

DBConnectorIndexedDB.prototype.getMany = function(tableName, arrKeys){
	var self = this;
    return new Promise(function(resolve, reject){
		if ( !arrKeys || !arrKeys.length )
			resolve([]);
        var arrResult = [];
        var getManyRecursive = function(index) {
            self.get(tableName, arrKeys[index])
			.then(function(result){
				if ( result && result.value )
					arrResult.push(result);
				if ( index == arrKeys.length - 1 )
					resolve(arrResult);
				else
					getManyRecursive(index + 1);
			});
		};
		getManyRecursive(0);
	});
};

/* version non optimale utilisant un cursor sur toute la table
DBConnectorIndexedDB.prototype.getMany = function(tableName, arrKeys) {
	var tx = this.db.transaction(tableName, "readwrite");
	var store = tx.objectStore(tableName);
	var keyRange = IDBKeyRange.lowerBound(0);
	var request = store.openCursor(keyRange);
	var data = [];
	return new Promise(function(resolve, reject){
		request.onsuccess = function(e) {
			var result = request.result;
			if (result) {
				if ( arrKeys.indexOf(result.key) != -1 )
					data.push(result.value);
				result.continue();
			}
			else
				resolve(data);
		};
	});
};

DBConnectorIndexedDB.prototype.log = function(tableName, key) {
	this.get(tableName, key)
	.then(res=>{element = res; console.dir(element)});
};
*/

/////////////
// Syncing //
/////////////

/////////////////
// Constructor //
/////////////////
function DBConnectorIndexedDB(dbName, dbVersion)
{
	DBConnector.call(this, dbName, dbVersion);
	this.name = "IndexedDB";
	this.monkeyPatch();
}